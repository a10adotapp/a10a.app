// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/a10adotapp/a10a.app/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/a10adotapp/a10a.app/ent/finschiaitemtoken"
	"github.com/a10adotapp/a10a.app/ent/finschiaitemtokenactivity"
	"github.com/a10adotapp/a10a.app/ent/finschiaitemtokenmillionarthursproperty"
	"github.com/a10adotapp/a10a.app/ent/linenft"
	"github.com/a10adotapp/a10a.app/ent/linenftactivity"
	"github.com/a10adotapp/a10a.app/ent/linenftmillionarthursproperty"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// FinschiaItemToken is the client for interacting with the FinschiaItemToken builders.
	FinschiaItemToken *FinschiaItemTokenClient
	// FinschiaItemTokenActivity is the client for interacting with the FinschiaItemTokenActivity builders.
	FinschiaItemTokenActivity *FinschiaItemTokenActivityClient
	// FinschiaItemTokenMillionArthursProperty is the client for interacting with the FinschiaItemTokenMillionArthursProperty builders.
	FinschiaItemTokenMillionArthursProperty *FinschiaItemTokenMillionArthursPropertyClient
	// LINENFT is the client for interacting with the LINENFT builders.
	LINENFT *LINENFTClient
	// LINENFTActivity is the client for interacting with the LINENFTActivity builders.
	LINENFTActivity *LINENFTActivityClient
	// LINENFTMillionArthursProperty is the client for interacting with the LINENFTMillionArthursProperty builders.
	LINENFTMillionArthursProperty *LINENFTMillionArthursPropertyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.FinschiaItemToken = NewFinschiaItemTokenClient(c.config)
	c.FinschiaItemTokenActivity = NewFinschiaItemTokenActivityClient(c.config)
	c.FinschiaItemTokenMillionArthursProperty = NewFinschiaItemTokenMillionArthursPropertyClient(c.config)
	c.LINENFT = NewLINENFTClient(c.config)
	c.LINENFTActivity = NewLINENFTActivityClient(c.config)
	c.LINENFTMillionArthursProperty = NewLINENFTMillionArthursPropertyClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                                     ctx,
		config:                                  cfg,
		FinschiaItemToken:                       NewFinschiaItemTokenClient(cfg),
		FinschiaItemTokenActivity:               NewFinschiaItemTokenActivityClient(cfg),
		FinschiaItemTokenMillionArthursProperty: NewFinschiaItemTokenMillionArthursPropertyClient(cfg),
		LINENFT:                                 NewLINENFTClient(cfg),
		LINENFTActivity:                         NewLINENFTActivityClient(cfg),
		LINENFTMillionArthursProperty:           NewLINENFTMillionArthursPropertyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                                     ctx,
		config:                                  cfg,
		FinschiaItemToken:                       NewFinschiaItemTokenClient(cfg),
		FinschiaItemTokenActivity:               NewFinschiaItemTokenActivityClient(cfg),
		FinschiaItemTokenMillionArthursProperty: NewFinschiaItemTokenMillionArthursPropertyClient(cfg),
		LINENFT:                                 NewLINENFTClient(cfg),
		LINENFTActivity:                         NewLINENFTActivityClient(cfg),
		LINENFTMillionArthursProperty:           NewLINENFTMillionArthursPropertyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		FinschiaItemToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.FinschiaItemToken, c.FinschiaItemTokenActivity,
		c.FinschiaItemTokenMillionArthursProperty, c.LINENFT, c.LINENFTActivity,
		c.LINENFTMillionArthursProperty,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.FinschiaItemToken, c.FinschiaItemTokenActivity,
		c.FinschiaItemTokenMillionArthursProperty, c.LINENFT, c.LINENFTActivity,
		c.LINENFTMillionArthursProperty,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *FinschiaItemTokenMutation:
		return c.FinschiaItemToken.mutate(ctx, m)
	case *FinschiaItemTokenActivityMutation:
		return c.FinschiaItemTokenActivity.mutate(ctx, m)
	case *FinschiaItemTokenMillionArthursPropertyMutation:
		return c.FinschiaItemTokenMillionArthursProperty.mutate(ctx, m)
	case *LINENFTMutation:
		return c.LINENFT.mutate(ctx, m)
	case *LINENFTActivityMutation:
		return c.LINENFTActivity.mutate(ctx, m)
	case *LINENFTMillionArthursPropertyMutation:
		return c.LINENFTMillionArthursProperty.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// FinschiaItemTokenClient is a client for the FinschiaItemToken schema.
type FinschiaItemTokenClient struct {
	config
}

// NewFinschiaItemTokenClient returns a client for the FinschiaItemToken from the given config.
func NewFinschiaItemTokenClient(c config) *FinschiaItemTokenClient {
	return &FinschiaItemTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `finschiaitemtoken.Hooks(f(g(h())))`.
func (c *FinschiaItemTokenClient) Use(hooks ...Hook) {
	c.hooks.FinschiaItemToken = append(c.hooks.FinschiaItemToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `finschiaitemtoken.Intercept(f(g(h())))`.
func (c *FinschiaItemTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.FinschiaItemToken = append(c.inters.FinschiaItemToken, interceptors...)
}

// Create returns a builder for creating a FinschiaItemToken entity.
func (c *FinschiaItemTokenClient) Create() *FinschiaItemTokenCreate {
	mutation := newFinschiaItemTokenMutation(c.config, OpCreate)
	return &FinschiaItemTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FinschiaItemToken entities.
func (c *FinschiaItemTokenClient) CreateBulk(builders ...*FinschiaItemTokenCreate) *FinschiaItemTokenCreateBulk {
	return &FinschiaItemTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FinschiaItemTokenClient) MapCreateBulk(slice any, setFunc func(*FinschiaItemTokenCreate, int)) *FinschiaItemTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FinschiaItemTokenCreateBulk{err: fmt.Errorf("calling to FinschiaItemTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FinschiaItemTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FinschiaItemTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FinschiaItemToken.
func (c *FinschiaItemTokenClient) Update() *FinschiaItemTokenUpdate {
	mutation := newFinschiaItemTokenMutation(c.config, OpUpdate)
	return &FinschiaItemTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FinschiaItemTokenClient) UpdateOne(fit *FinschiaItemToken) *FinschiaItemTokenUpdateOne {
	mutation := newFinschiaItemTokenMutation(c.config, OpUpdateOne, withFinschiaItemToken(fit))
	return &FinschiaItemTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FinschiaItemTokenClient) UpdateOneID(id uint32) *FinschiaItemTokenUpdateOne {
	mutation := newFinschiaItemTokenMutation(c.config, OpUpdateOne, withFinschiaItemTokenID(id))
	return &FinschiaItemTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FinschiaItemToken.
func (c *FinschiaItemTokenClient) Delete() *FinschiaItemTokenDelete {
	mutation := newFinschiaItemTokenMutation(c.config, OpDelete)
	return &FinschiaItemTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FinschiaItemTokenClient) DeleteOne(fit *FinschiaItemToken) *FinschiaItemTokenDeleteOne {
	return c.DeleteOneID(fit.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FinschiaItemTokenClient) DeleteOneID(id uint32) *FinschiaItemTokenDeleteOne {
	builder := c.Delete().Where(finschiaitemtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FinschiaItemTokenDeleteOne{builder}
}

// Query returns a query builder for FinschiaItemToken.
func (c *FinschiaItemTokenClient) Query() *FinschiaItemTokenQuery {
	return &FinschiaItemTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinschiaItemToken},
		inters: c.Interceptors(),
	}
}

// Get returns a FinschiaItemToken entity by its id.
func (c *FinschiaItemTokenClient) Get(ctx context.Context, id uint32) (*FinschiaItemToken, error) {
	return c.Query().Where(finschiaitemtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FinschiaItemTokenClient) GetX(ctx context.Context, id uint32) *FinschiaItemToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActivities queries the activities edge of a FinschiaItemToken.
func (c *FinschiaItemTokenClient) QueryActivities(fit *FinschiaItemToken) *FinschiaItemTokenActivityQuery {
	query := (&FinschiaItemTokenActivityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fit.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finschiaitemtoken.Table, finschiaitemtoken.FieldID, id),
			sqlgraph.To(finschiaitemtokenactivity.Table, finschiaitemtokenactivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finschiaitemtoken.ActivitiesTable, finschiaitemtoken.ActivitiesColumn),
		)
		fromV = sqlgraph.Neighbors(fit.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMillionArthursProperties queries the million_arthurs_properties edge of a FinschiaItemToken.
func (c *FinschiaItemTokenClient) QueryMillionArthursProperties(fit *FinschiaItemToken) *FinschiaItemTokenMillionArthursPropertyQuery {
	query := (&FinschiaItemTokenMillionArthursPropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fit.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finschiaitemtoken.Table, finschiaitemtoken.FieldID, id),
			sqlgraph.To(finschiaitemtokenmillionarthursproperty.Table, finschiaitemtokenmillionarthursproperty.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finschiaitemtoken.MillionArthursPropertiesTable, finschiaitemtoken.MillionArthursPropertiesColumn),
		)
		fromV = sqlgraph.Neighbors(fit.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FinschiaItemTokenClient) Hooks() []Hook {
	hooks := c.hooks.FinschiaItemToken
	return append(hooks[:len(hooks):len(hooks)], finschiaitemtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FinschiaItemTokenClient) Interceptors() []Interceptor {
	inters := c.inters.FinschiaItemToken
	return append(inters[:len(inters):len(inters)], finschiaitemtoken.Interceptors[:]...)
}

func (c *FinschiaItemTokenClient) mutate(ctx context.Context, m *FinschiaItemTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FinschiaItemTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FinschiaItemTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FinschiaItemTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FinschiaItemTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FinschiaItemToken mutation op: %q", m.Op())
	}
}

// FinschiaItemTokenActivityClient is a client for the FinschiaItemTokenActivity schema.
type FinschiaItemTokenActivityClient struct {
	config
}

// NewFinschiaItemTokenActivityClient returns a client for the FinschiaItemTokenActivity from the given config.
func NewFinschiaItemTokenActivityClient(c config) *FinschiaItemTokenActivityClient {
	return &FinschiaItemTokenActivityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `finschiaitemtokenactivity.Hooks(f(g(h())))`.
func (c *FinschiaItemTokenActivityClient) Use(hooks ...Hook) {
	c.hooks.FinschiaItemTokenActivity = append(c.hooks.FinschiaItemTokenActivity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `finschiaitemtokenactivity.Intercept(f(g(h())))`.
func (c *FinschiaItemTokenActivityClient) Intercept(interceptors ...Interceptor) {
	c.inters.FinschiaItemTokenActivity = append(c.inters.FinschiaItemTokenActivity, interceptors...)
}

// Create returns a builder for creating a FinschiaItemTokenActivity entity.
func (c *FinschiaItemTokenActivityClient) Create() *FinschiaItemTokenActivityCreate {
	mutation := newFinschiaItemTokenActivityMutation(c.config, OpCreate)
	return &FinschiaItemTokenActivityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FinschiaItemTokenActivity entities.
func (c *FinschiaItemTokenActivityClient) CreateBulk(builders ...*FinschiaItemTokenActivityCreate) *FinschiaItemTokenActivityCreateBulk {
	return &FinschiaItemTokenActivityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FinschiaItemTokenActivityClient) MapCreateBulk(slice any, setFunc func(*FinschiaItemTokenActivityCreate, int)) *FinschiaItemTokenActivityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FinschiaItemTokenActivityCreateBulk{err: fmt.Errorf("calling to FinschiaItemTokenActivityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FinschiaItemTokenActivityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FinschiaItemTokenActivityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FinschiaItemTokenActivity.
func (c *FinschiaItemTokenActivityClient) Update() *FinschiaItemTokenActivityUpdate {
	mutation := newFinschiaItemTokenActivityMutation(c.config, OpUpdate)
	return &FinschiaItemTokenActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FinschiaItemTokenActivityClient) UpdateOne(fita *FinschiaItemTokenActivity) *FinschiaItemTokenActivityUpdateOne {
	mutation := newFinschiaItemTokenActivityMutation(c.config, OpUpdateOne, withFinschiaItemTokenActivity(fita))
	return &FinschiaItemTokenActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FinschiaItemTokenActivityClient) UpdateOneID(id uint32) *FinschiaItemTokenActivityUpdateOne {
	mutation := newFinschiaItemTokenActivityMutation(c.config, OpUpdateOne, withFinschiaItemTokenActivityID(id))
	return &FinschiaItemTokenActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FinschiaItemTokenActivity.
func (c *FinschiaItemTokenActivityClient) Delete() *FinschiaItemTokenActivityDelete {
	mutation := newFinschiaItemTokenActivityMutation(c.config, OpDelete)
	return &FinschiaItemTokenActivityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FinschiaItemTokenActivityClient) DeleteOne(fita *FinschiaItemTokenActivity) *FinschiaItemTokenActivityDeleteOne {
	return c.DeleteOneID(fita.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FinschiaItemTokenActivityClient) DeleteOneID(id uint32) *FinschiaItemTokenActivityDeleteOne {
	builder := c.Delete().Where(finschiaitemtokenactivity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FinschiaItemTokenActivityDeleteOne{builder}
}

// Query returns a query builder for FinschiaItemTokenActivity.
func (c *FinschiaItemTokenActivityClient) Query() *FinschiaItemTokenActivityQuery {
	return &FinschiaItemTokenActivityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinschiaItemTokenActivity},
		inters: c.Interceptors(),
	}
}

// Get returns a FinschiaItemTokenActivity entity by its id.
func (c *FinschiaItemTokenActivityClient) Get(ctx context.Context, id uint32) (*FinschiaItemTokenActivity, error) {
	return c.Query().Where(finschiaitemtokenactivity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FinschiaItemTokenActivityClient) GetX(ctx context.Context, id uint32) *FinschiaItemTokenActivity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFinschiaItemToken queries the finschia_item_token edge of a FinschiaItemTokenActivity.
func (c *FinschiaItemTokenActivityClient) QueryFinschiaItemToken(fita *FinschiaItemTokenActivity) *FinschiaItemTokenQuery {
	query := (&FinschiaItemTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fita.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finschiaitemtokenactivity.Table, finschiaitemtokenactivity.FieldID, id),
			sqlgraph.To(finschiaitemtoken.Table, finschiaitemtoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finschiaitemtokenactivity.FinschiaItemTokenTable, finschiaitemtokenactivity.FinschiaItemTokenColumn),
		)
		fromV = sqlgraph.Neighbors(fita.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FinschiaItemTokenActivityClient) Hooks() []Hook {
	hooks := c.hooks.FinschiaItemTokenActivity
	return append(hooks[:len(hooks):len(hooks)], finschiaitemtokenactivity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FinschiaItemTokenActivityClient) Interceptors() []Interceptor {
	inters := c.inters.FinschiaItemTokenActivity
	return append(inters[:len(inters):len(inters)], finschiaitemtokenactivity.Interceptors[:]...)
}

func (c *FinschiaItemTokenActivityClient) mutate(ctx context.Context, m *FinschiaItemTokenActivityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FinschiaItemTokenActivityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FinschiaItemTokenActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FinschiaItemTokenActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FinschiaItemTokenActivityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FinschiaItemTokenActivity mutation op: %q", m.Op())
	}
}

// FinschiaItemTokenMillionArthursPropertyClient is a client for the FinschiaItemTokenMillionArthursProperty schema.
type FinschiaItemTokenMillionArthursPropertyClient struct {
	config
}

// NewFinschiaItemTokenMillionArthursPropertyClient returns a client for the FinschiaItemTokenMillionArthursProperty from the given config.
func NewFinschiaItemTokenMillionArthursPropertyClient(c config) *FinschiaItemTokenMillionArthursPropertyClient {
	return &FinschiaItemTokenMillionArthursPropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `finschiaitemtokenmillionarthursproperty.Hooks(f(g(h())))`.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Use(hooks ...Hook) {
	c.hooks.FinschiaItemTokenMillionArthursProperty = append(c.hooks.FinschiaItemTokenMillionArthursProperty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `finschiaitemtokenmillionarthursproperty.Intercept(f(g(h())))`.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.FinschiaItemTokenMillionArthursProperty = append(c.inters.FinschiaItemTokenMillionArthursProperty, interceptors...)
}

// Create returns a builder for creating a FinschiaItemTokenMillionArthursProperty entity.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Create() *FinschiaItemTokenMillionArthursPropertyCreate {
	mutation := newFinschiaItemTokenMillionArthursPropertyMutation(c.config, OpCreate)
	return &FinschiaItemTokenMillionArthursPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FinschiaItemTokenMillionArthursProperty entities.
func (c *FinschiaItemTokenMillionArthursPropertyClient) CreateBulk(builders ...*FinschiaItemTokenMillionArthursPropertyCreate) *FinschiaItemTokenMillionArthursPropertyCreateBulk {
	return &FinschiaItemTokenMillionArthursPropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FinschiaItemTokenMillionArthursPropertyClient) MapCreateBulk(slice any, setFunc func(*FinschiaItemTokenMillionArthursPropertyCreate, int)) *FinschiaItemTokenMillionArthursPropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FinschiaItemTokenMillionArthursPropertyCreateBulk{err: fmt.Errorf("calling to FinschiaItemTokenMillionArthursPropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FinschiaItemTokenMillionArthursPropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FinschiaItemTokenMillionArthursPropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FinschiaItemTokenMillionArthursProperty.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Update() *FinschiaItemTokenMillionArthursPropertyUpdate {
	mutation := newFinschiaItemTokenMillionArthursPropertyMutation(c.config, OpUpdate)
	return &FinschiaItemTokenMillionArthursPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FinschiaItemTokenMillionArthursPropertyClient) UpdateOne(fitmap *FinschiaItemTokenMillionArthursProperty) *FinschiaItemTokenMillionArthursPropertyUpdateOne {
	mutation := newFinschiaItemTokenMillionArthursPropertyMutation(c.config, OpUpdateOne, withFinschiaItemTokenMillionArthursProperty(fitmap))
	return &FinschiaItemTokenMillionArthursPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FinschiaItemTokenMillionArthursPropertyClient) UpdateOneID(id uint32) *FinschiaItemTokenMillionArthursPropertyUpdateOne {
	mutation := newFinschiaItemTokenMillionArthursPropertyMutation(c.config, OpUpdateOne, withFinschiaItemTokenMillionArthursPropertyID(id))
	return &FinschiaItemTokenMillionArthursPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FinschiaItemTokenMillionArthursProperty.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Delete() *FinschiaItemTokenMillionArthursPropertyDelete {
	mutation := newFinschiaItemTokenMillionArthursPropertyMutation(c.config, OpDelete)
	return &FinschiaItemTokenMillionArthursPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FinschiaItemTokenMillionArthursPropertyClient) DeleteOne(fitmap *FinschiaItemTokenMillionArthursProperty) *FinschiaItemTokenMillionArthursPropertyDeleteOne {
	return c.DeleteOneID(fitmap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FinschiaItemTokenMillionArthursPropertyClient) DeleteOneID(id uint32) *FinschiaItemTokenMillionArthursPropertyDeleteOne {
	builder := c.Delete().Where(finschiaitemtokenmillionarthursproperty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FinschiaItemTokenMillionArthursPropertyDeleteOne{builder}
}

// Query returns a query builder for FinschiaItemTokenMillionArthursProperty.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Query() *FinschiaItemTokenMillionArthursPropertyQuery {
	return &FinschiaItemTokenMillionArthursPropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinschiaItemTokenMillionArthursProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a FinschiaItemTokenMillionArthursProperty entity by its id.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Get(ctx context.Context, id uint32) (*FinschiaItemTokenMillionArthursProperty, error) {
	return c.Query().Where(finschiaitemtokenmillionarthursproperty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FinschiaItemTokenMillionArthursPropertyClient) GetX(ctx context.Context, id uint32) *FinschiaItemTokenMillionArthursProperty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFinschiaItemToken queries the finschia_item_token edge of a FinschiaItemTokenMillionArthursProperty.
func (c *FinschiaItemTokenMillionArthursPropertyClient) QueryFinschiaItemToken(fitmap *FinschiaItemTokenMillionArthursProperty) *FinschiaItemTokenQuery {
	query := (&FinschiaItemTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fitmap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finschiaitemtokenmillionarthursproperty.Table, finschiaitemtokenmillionarthursproperty.FieldID, id),
			sqlgraph.To(finschiaitemtoken.Table, finschiaitemtoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finschiaitemtokenmillionarthursproperty.FinschiaItemTokenTable, finschiaitemtokenmillionarthursproperty.FinschiaItemTokenColumn),
		)
		fromV = sqlgraph.Neighbors(fitmap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Hooks() []Hook {
	hooks := c.hooks.FinschiaItemTokenMillionArthursProperty
	return append(hooks[:len(hooks):len(hooks)], finschiaitemtokenmillionarthursproperty.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FinschiaItemTokenMillionArthursPropertyClient) Interceptors() []Interceptor {
	inters := c.inters.FinschiaItemTokenMillionArthursProperty
	return append(inters[:len(inters):len(inters)], finschiaitemtokenmillionarthursproperty.Interceptors[:]...)
}

func (c *FinschiaItemTokenMillionArthursPropertyClient) mutate(ctx context.Context, m *FinschiaItemTokenMillionArthursPropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FinschiaItemTokenMillionArthursPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FinschiaItemTokenMillionArthursPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FinschiaItemTokenMillionArthursPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FinschiaItemTokenMillionArthursPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FinschiaItemTokenMillionArthursProperty mutation op: %q", m.Op())
	}
}

// LINENFTClient is a client for the LINENFT schema.
type LINENFTClient struct {
	config
}

// NewLINENFTClient returns a client for the LINENFT from the given config.
func NewLINENFTClient(c config) *LINENFTClient {
	return &LINENFTClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `linenft.Hooks(f(g(h())))`.
func (c *LINENFTClient) Use(hooks ...Hook) {
	c.hooks.LINENFT = append(c.hooks.LINENFT, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `linenft.Intercept(f(g(h())))`.
func (c *LINENFTClient) Intercept(interceptors ...Interceptor) {
	c.inters.LINENFT = append(c.inters.LINENFT, interceptors...)
}

// Create returns a builder for creating a LINENFT entity.
func (c *LINENFTClient) Create() *LINENFTCreate {
	mutation := newLINENFTMutation(c.config, OpCreate)
	return &LINENFTCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LINENFT entities.
func (c *LINENFTClient) CreateBulk(builders ...*LINENFTCreate) *LINENFTCreateBulk {
	return &LINENFTCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LINENFTClient) MapCreateBulk(slice any, setFunc func(*LINENFTCreate, int)) *LINENFTCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LINENFTCreateBulk{err: fmt.Errorf("calling to LINENFTClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LINENFTCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LINENFTCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LINENFT.
func (c *LINENFTClient) Update() *LINENFTUpdate {
	mutation := newLINENFTMutation(c.config, OpUpdate)
	return &LINENFTUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LINENFTClient) UpdateOne(l *LINENFT) *LINENFTUpdateOne {
	mutation := newLINENFTMutation(c.config, OpUpdateOne, withLINENFT(l))
	return &LINENFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LINENFTClient) UpdateOneID(id uint32) *LINENFTUpdateOne {
	mutation := newLINENFTMutation(c.config, OpUpdateOne, withLINENFTID(id))
	return &LINENFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LINENFT.
func (c *LINENFTClient) Delete() *LINENFTDelete {
	mutation := newLINENFTMutation(c.config, OpDelete)
	return &LINENFTDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LINENFTClient) DeleteOne(l *LINENFT) *LINENFTDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LINENFTClient) DeleteOneID(id uint32) *LINENFTDeleteOne {
	builder := c.Delete().Where(linenft.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LINENFTDeleteOne{builder}
}

// Query returns a query builder for LINENFT.
func (c *LINENFTClient) Query() *LINENFTQuery {
	return &LINENFTQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLINENFT},
		inters: c.Interceptors(),
	}
}

// Get returns a LINENFT entity by its id.
func (c *LINENFTClient) Get(ctx context.Context, id uint32) (*LINENFT, error) {
	return c.Query().Where(linenft.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LINENFTClient) GetX(ctx context.Context, id uint32) *LINENFT {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActivities queries the activities edge of a LINENFT.
func (c *LINENFTClient) QueryActivities(l *LINENFT) *LINENFTActivityQuery {
	query := (&LINENFTActivityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(linenft.Table, linenft.FieldID, id),
			sqlgraph.To(linenftactivity.Table, linenftactivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, linenft.ActivitiesTable, linenft.ActivitiesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMillionArthursProperties queries the million_arthurs_properties edge of a LINENFT.
func (c *LINENFTClient) QueryMillionArthursProperties(l *LINENFT) *LINENFTMillionArthursPropertyQuery {
	query := (&LINENFTMillionArthursPropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(linenft.Table, linenft.FieldID, id),
			sqlgraph.To(linenftmillionarthursproperty.Table, linenftmillionarthursproperty.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, linenft.MillionArthursPropertiesTable, linenft.MillionArthursPropertiesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LINENFTClient) Hooks() []Hook {
	hooks := c.hooks.LINENFT
	return append(hooks[:len(hooks):len(hooks)], linenft.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LINENFTClient) Interceptors() []Interceptor {
	inters := c.inters.LINENFT
	return append(inters[:len(inters):len(inters)], linenft.Interceptors[:]...)
}

func (c *LINENFTClient) mutate(ctx context.Context, m *LINENFTMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LINENFTCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LINENFTUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LINENFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LINENFTDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LINENFT mutation op: %q", m.Op())
	}
}

// LINENFTActivityClient is a client for the LINENFTActivity schema.
type LINENFTActivityClient struct {
	config
}

// NewLINENFTActivityClient returns a client for the LINENFTActivity from the given config.
func NewLINENFTActivityClient(c config) *LINENFTActivityClient {
	return &LINENFTActivityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `linenftactivity.Hooks(f(g(h())))`.
func (c *LINENFTActivityClient) Use(hooks ...Hook) {
	c.hooks.LINENFTActivity = append(c.hooks.LINENFTActivity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `linenftactivity.Intercept(f(g(h())))`.
func (c *LINENFTActivityClient) Intercept(interceptors ...Interceptor) {
	c.inters.LINENFTActivity = append(c.inters.LINENFTActivity, interceptors...)
}

// Create returns a builder for creating a LINENFTActivity entity.
func (c *LINENFTActivityClient) Create() *LINENFTActivityCreate {
	mutation := newLINENFTActivityMutation(c.config, OpCreate)
	return &LINENFTActivityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LINENFTActivity entities.
func (c *LINENFTActivityClient) CreateBulk(builders ...*LINENFTActivityCreate) *LINENFTActivityCreateBulk {
	return &LINENFTActivityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LINENFTActivityClient) MapCreateBulk(slice any, setFunc func(*LINENFTActivityCreate, int)) *LINENFTActivityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LINENFTActivityCreateBulk{err: fmt.Errorf("calling to LINENFTActivityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LINENFTActivityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LINENFTActivityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LINENFTActivity.
func (c *LINENFTActivityClient) Update() *LINENFTActivityUpdate {
	mutation := newLINENFTActivityMutation(c.config, OpUpdate)
	return &LINENFTActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LINENFTActivityClient) UpdateOne(la *LINENFTActivity) *LINENFTActivityUpdateOne {
	mutation := newLINENFTActivityMutation(c.config, OpUpdateOne, withLINENFTActivity(la))
	return &LINENFTActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LINENFTActivityClient) UpdateOneID(id uint32) *LINENFTActivityUpdateOne {
	mutation := newLINENFTActivityMutation(c.config, OpUpdateOne, withLINENFTActivityID(id))
	return &LINENFTActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LINENFTActivity.
func (c *LINENFTActivityClient) Delete() *LINENFTActivityDelete {
	mutation := newLINENFTActivityMutation(c.config, OpDelete)
	return &LINENFTActivityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LINENFTActivityClient) DeleteOne(la *LINENFTActivity) *LINENFTActivityDeleteOne {
	return c.DeleteOneID(la.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LINENFTActivityClient) DeleteOneID(id uint32) *LINENFTActivityDeleteOne {
	builder := c.Delete().Where(linenftactivity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LINENFTActivityDeleteOne{builder}
}

// Query returns a query builder for LINENFTActivity.
func (c *LINENFTActivityClient) Query() *LINENFTActivityQuery {
	return &LINENFTActivityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLINENFTActivity},
		inters: c.Interceptors(),
	}
}

// Get returns a LINENFTActivity entity by its id.
func (c *LINENFTActivityClient) Get(ctx context.Context, id uint32) (*LINENFTActivity, error) {
	return c.Query().Where(linenftactivity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LINENFTActivityClient) GetX(ctx context.Context, id uint32) *LINENFTActivity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLineNft queries the line_nft edge of a LINENFTActivity.
func (c *LINENFTActivityClient) QueryLineNft(la *LINENFTActivity) *LINENFTQuery {
	query := (&LINENFTClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := la.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(linenftactivity.Table, linenftactivity.FieldID, id),
			sqlgraph.To(linenft.Table, linenft.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, linenftactivity.LineNftTable, linenftactivity.LineNftColumn),
		)
		fromV = sqlgraph.Neighbors(la.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LINENFTActivityClient) Hooks() []Hook {
	hooks := c.hooks.LINENFTActivity
	return append(hooks[:len(hooks):len(hooks)], linenftactivity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LINENFTActivityClient) Interceptors() []Interceptor {
	inters := c.inters.LINENFTActivity
	return append(inters[:len(inters):len(inters)], linenftactivity.Interceptors[:]...)
}

func (c *LINENFTActivityClient) mutate(ctx context.Context, m *LINENFTActivityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LINENFTActivityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LINENFTActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LINENFTActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LINENFTActivityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LINENFTActivity mutation op: %q", m.Op())
	}
}

// LINENFTMillionArthursPropertyClient is a client for the LINENFTMillionArthursProperty schema.
type LINENFTMillionArthursPropertyClient struct {
	config
}

// NewLINENFTMillionArthursPropertyClient returns a client for the LINENFTMillionArthursProperty from the given config.
func NewLINENFTMillionArthursPropertyClient(c config) *LINENFTMillionArthursPropertyClient {
	return &LINENFTMillionArthursPropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `linenftmillionarthursproperty.Hooks(f(g(h())))`.
func (c *LINENFTMillionArthursPropertyClient) Use(hooks ...Hook) {
	c.hooks.LINENFTMillionArthursProperty = append(c.hooks.LINENFTMillionArthursProperty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `linenftmillionarthursproperty.Intercept(f(g(h())))`.
func (c *LINENFTMillionArthursPropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.LINENFTMillionArthursProperty = append(c.inters.LINENFTMillionArthursProperty, interceptors...)
}

// Create returns a builder for creating a LINENFTMillionArthursProperty entity.
func (c *LINENFTMillionArthursPropertyClient) Create() *LINENFTMillionArthursPropertyCreate {
	mutation := newLINENFTMillionArthursPropertyMutation(c.config, OpCreate)
	return &LINENFTMillionArthursPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LINENFTMillionArthursProperty entities.
func (c *LINENFTMillionArthursPropertyClient) CreateBulk(builders ...*LINENFTMillionArthursPropertyCreate) *LINENFTMillionArthursPropertyCreateBulk {
	return &LINENFTMillionArthursPropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LINENFTMillionArthursPropertyClient) MapCreateBulk(slice any, setFunc func(*LINENFTMillionArthursPropertyCreate, int)) *LINENFTMillionArthursPropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LINENFTMillionArthursPropertyCreateBulk{err: fmt.Errorf("calling to LINENFTMillionArthursPropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LINENFTMillionArthursPropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LINENFTMillionArthursPropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LINENFTMillionArthursProperty.
func (c *LINENFTMillionArthursPropertyClient) Update() *LINENFTMillionArthursPropertyUpdate {
	mutation := newLINENFTMillionArthursPropertyMutation(c.config, OpUpdate)
	return &LINENFTMillionArthursPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LINENFTMillionArthursPropertyClient) UpdateOne(lmap *LINENFTMillionArthursProperty) *LINENFTMillionArthursPropertyUpdateOne {
	mutation := newLINENFTMillionArthursPropertyMutation(c.config, OpUpdateOne, withLINENFTMillionArthursProperty(lmap))
	return &LINENFTMillionArthursPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LINENFTMillionArthursPropertyClient) UpdateOneID(id uint32) *LINENFTMillionArthursPropertyUpdateOne {
	mutation := newLINENFTMillionArthursPropertyMutation(c.config, OpUpdateOne, withLINENFTMillionArthursPropertyID(id))
	return &LINENFTMillionArthursPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LINENFTMillionArthursProperty.
func (c *LINENFTMillionArthursPropertyClient) Delete() *LINENFTMillionArthursPropertyDelete {
	mutation := newLINENFTMillionArthursPropertyMutation(c.config, OpDelete)
	return &LINENFTMillionArthursPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LINENFTMillionArthursPropertyClient) DeleteOne(lmap *LINENFTMillionArthursProperty) *LINENFTMillionArthursPropertyDeleteOne {
	return c.DeleteOneID(lmap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LINENFTMillionArthursPropertyClient) DeleteOneID(id uint32) *LINENFTMillionArthursPropertyDeleteOne {
	builder := c.Delete().Where(linenftmillionarthursproperty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LINENFTMillionArthursPropertyDeleteOne{builder}
}

// Query returns a query builder for LINENFTMillionArthursProperty.
func (c *LINENFTMillionArthursPropertyClient) Query() *LINENFTMillionArthursPropertyQuery {
	return &LINENFTMillionArthursPropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLINENFTMillionArthursProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a LINENFTMillionArthursProperty entity by its id.
func (c *LINENFTMillionArthursPropertyClient) Get(ctx context.Context, id uint32) (*LINENFTMillionArthursProperty, error) {
	return c.Query().Where(linenftmillionarthursproperty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LINENFTMillionArthursPropertyClient) GetX(ctx context.Context, id uint32) *LINENFTMillionArthursProperty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLineNft queries the line_nft edge of a LINENFTMillionArthursProperty.
func (c *LINENFTMillionArthursPropertyClient) QueryLineNft(lmap *LINENFTMillionArthursProperty) *LINENFTQuery {
	query := (&LINENFTClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lmap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(linenftmillionarthursproperty.Table, linenftmillionarthursproperty.FieldID, id),
			sqlgraph.To(linenft.Table, linenft.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, linenftmillionarthursproperty.LineNftTable, linenftmillionarthursproperty.LineNftColumn),
		)
		fromV = sqlgraph.Neighbors(lmap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LINENFTMillionArthursPropertyClient) Hooks() []Hook {
	hooks := c.hooks.LINENFTMillionArthursProperty
	return append(hooks[:len(hooks):len(hooks)], linenftmillionarthursproperty.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LINENFTMillionArthursPropertyClient) Interceptors() []Interceptor {
	inters := c.inters.LINENFTMillionArthursProperty
	return append(inters[:len(inters):len(inters)], linenftmillionarthursproperty.Interceptors[:]...)
}

func (c *LINENFTMillionArthursPropertyClient) mutate(ctx context.Context, m *LINENFTMillionArthursPropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LINENFTMillionArthursPropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LINENFTMillionArthursPropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LINENFTMillionArthursPropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LINENFTMillionArthursPropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LINENFTMillionArthursProperty mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		FinschiaItemToken, FinschiaItemTokenActivity,
		FinschiaItemTokenMillionArthursProperty, LINENFT, LINENFTActivity,
		LINENFTMillionArthursProperty []ent.Hook
	}
	inters struct {
		FinschiaItemToken, FinschiaItemTokenActivity,
		FinschiaItemTokenMillionArthursProperty, LINENFT, LINENFTActivity,
		LINENFTMillionArthursProperty []ent.Interceptor
	}
)
