// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/a10adotapp/a10a.app/ent/changokushiweapon"
	"github.com/a10adotapp/a10a.app/ent/changokushiweaponchangelog"
	"github.com/a10adotapp/a10a.app/ent/predicate"
	"github.com/a10adotapp/a10a.app/ent/sanmeihoikuenpost"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChangokushiWeapon          = "ChangokushiWeapon"
	TypeChangokushiWeaponChangeLog = "ChangokushiWeaponChangeLog"
	TypeSanmeiHoikuenPost          = "SanmeiHoikuenPost"
)

// ChangokushiWeaponMutation represents an operation that mutates the ChangokushiWeapon nodes in the graph.
type ChangokushiWeaponMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint32
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	uri                 *string
	name                *string
	rank                *int
	addrank             *int
	_type               *string
	skill               *string
	vitality            *int
	addvitality         *int
	strength            *int
	addstrength         *int
	physical_defense    *int
	addphysical_defense *int
	magical_defense     *int
	addmagical_defense  *int
	agility             *int
	addagility          *int
	clearedFields       map[string]struct{}
	change_logs         map[uint32]struct{}
	removedchange_logs  map[uint32]struct{}
	clearedchange_logs  bool
	done                bool
	oldValue            func(context.Context) (*ChangokushiWeapon, error)
	predicates          []predicate.ChangokushiWeapon
}

var _ ent.Mutation = (*ChangokushiWeaponMutation)(nil)

// changokushiweaponOption allows management of the mutation configuration using functional options.
type changokushiweaponOption func(*ChangokushiWeaponMutation)

// newChangokushiWeaponMutation creates new mutation for the ChangokushiWeapon entity.
func newChangokushiWeaponMutation(c config, op Op, opts ...changokushiweaponOption) *ChangokushiWeaponMutation {
	m := &ChangokushiWeaponMutation{
		config:        c,
		op:            op,
		typ:           TypeChangokushiWeapon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangokushiWeaponID sets the ID field of the mutation.
func withChangokushiWeaponID(id uint32) changokushiweaponOption {
	return func(m *ChangokushiWeaponMutation) {
		var (
			err   error
			once  sync.Once
			value *ChangokushiWeapon
		)
		m.oldValue = func(ctx context.Context) (*ChangokushiWeapon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChangokushiWeapon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChangokushiWeapon sets the old ChangokushiWeapon of the mutation.
func withChangokushiWeapon(node *ChangokushiWeapon) changokushiweaponOption {
	return func(m *ChangokushiWeaponMutation) {
		m.oldValue = func(context.Context) (*ChangokushiWeapon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangokushiWeaponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangokushiWeaponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChangokushiWeapon entities.
func (m *ChangokushiWeaponMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangokushiWeaponMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangokushiWeaponMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChangokushiWeapon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangokushiWeaponMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangokushiWeaponMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangokushiWeaponMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChangokushiWeaponMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChangokushiWeaponMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChangokushiWeaponMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChangokushiWeaponMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChangokushiWeaponMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChangokushiWeaponMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[changokushiweapon.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChangokushiWeaponMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[changokushiweapon.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChangokushiWeaponMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, changokushiweapon.FieldDeletedAt)
}

// SetURI sets the "uri" field.
func (m *ChangokushiWeaponMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *ChangokushiWeaponMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *ChangokushiWeaponMutation) ResetURI() {
	m.uri = nil
}

// SetName sets the "name" field.
func (m *ChangokushiWeaponMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChangokushiWeaponMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChangokushiWeaponMutation) ResetName() {
	m.name = nil
}

// SetRank sets the "rank" field.
func (m *ChangokushiWeaponMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *ChangokushiWeaponMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *ChangokushiWeaponMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *ChangokushiWeaponMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *ChangokushiWeaponMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetType sets the "type" field.
func (m *ChangokushiWeaponMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChangokushiWeaponMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChangokushiWeaponMutation) ResetType() {
	m._type = nil
}

// SetSkill sets the "skill" field.
func (m *ChangokushiWeaponMutation) SetSkill(s string) {
	m.skill = &s
}

// Skill returns the value of the "skill" field in the mutation.
func (m *ChangokushiWeaponMutation) Skill() (r string, exists bool) {
	v := m.skill
	if v == nil {
		return
	}
	return *v, true
}

// OldSkill returns the old "skill" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldSkill(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkill: %w", err)
	}
	return oldValue.Skill, nil
}

// ResetSkill resets all changes to the "skill" field.
func (m *ChangokushiWeaponMutation) ResetSkill() {
	m.skill = nil
}

// SetVitality sets the "vitality" field.
func (m *ChangokushiWeaponMutation) SetVitality(i int) {
	m.vitality = &i
	m.addvitality = nil
}

// Vitality returns the value of the "vitality" field in the mutation.
func (m *ChangokushiWeaponMutation) Vitality() (r int, exists bool) {
	v := m.vitality
	if v == nil {
		return
	}
	return *v, true
}

// OldVitality returns the old "vitality" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldVitality(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVitality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVitality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVitality: %w", err)
	}
	return oldValue.Vitality, nil
}

// AddVitality adds i to the "vitality" field.
func (m *ChangokushiWeaponMutation) AddVitality(i int) {
	if m.addvitality != nil {
		*m.addvitality += i
	} else {
		m.addvitality = &i
	}
}

// AddedVitality returns the value that was added to the "vitality" field in this mutation.
func (m *ChangokushiWeaponMutation) AddedVitality() (r int, exists bool) {
	v := m.addvitality
	if v == nil {
		return
	}
	return *v, true
}

// ResetVitality resets all changes to the "vitality" field.
func (m *ChangokushiWeaponMutation) ResetVitality() {
	m.vitality = nil
	m.addvitality = nil
}

// SetStrength sets the "strength" field.
func (m *ChangokushiWeaponMutation) SetStrength(i int) {
	m.strength = &i
	m.addstrength = nil
}

// Strength returns the value of the "strength" field in the mutation.
func (m *ChangokushiWeaponMutation) Strength() (r int, exists bool) {
	v := m.strength
	if v == nil {
		return
	}
	return *v, true
}

// OldStrength returns the old "strength" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldStrength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrength: %w", err)
	}
	return oldValue.Strength, nil
}

// AddStrength adds i to the "strength" field.
func (m *ChangokushiWeaponMutation) AddStrength(i int) {
	if m.addstrength != nil {
		*m.addstrength += i
	} else {
		m.addstrength = &i
	}
}

// AddedStrength returns the value that was added to the "strength" field in this mutation.
func (m *ChangokushiWeaponMutation) AddedStrength() (r int, exists bool) {
	v := m.addstrength
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrength resets all changes to the "strength" field.
func (m *ChangokushiWeaponMutation) ResetStrength() {
	m.strength = nil
	m.addstrength = nil
}

// SetPhysicalDefense sets the "physical_defense" field.
func (m *ChangokushiWeaponMutation) SetPhysicalDefense(i int) {
	m.physical_defense = &i
	m.addphysical_defense = nil
}

// PhysicalDefense returns the value of the "physical_defense" field in the mutation.
func (m *ChangokushiWeaponMutation) PhysicalDefense() (r int, exists bool) {
	v := m.physical_defense
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalDefense returns the old "physical_defense" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldPhysicalDefense(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhysicalDefense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhysicalDefense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalDefense: %w", err)
	}
	return oldValue.PhysicalDefense, nil
}

// AddPhysicalDefense adds i to the "physical_defense" field.
func (m *ChangokushiWeaponMutation) AddPhysicalDefense(i int) {
	if m.addphysical_defense != nil {
		*m.addphysical_defense += i
	} else {
		m.addphysical_defense = &i
	}
}

// AddedPhysicalDefense returns the value that was added to the "physical_defense" field in this mutation.
func (m *ChangokushiWeaponMutation) AddedPhysicalDefense() (r int, exists bool) {
	v := m.addphysical_defense
	if v == nil {
		return
	}
	return *v, true
}

// ResetPhysicalDefense resets all changes to the "physical_defense" field.
func (m *ChangokushiWeaponMutation) ResetPhysicalDefense() {
	m.physical_defense = nil
	m.addphysical_defense = nil
}

// SetMagicalDefense sets the "magical_defense" field.
func (m *ChangokushiWeaponMutation) SetMagicalDefense(i int) {
	m.magical_defense = &i
	m.addmagical_defense = nil
}

// MagicalDefense returns the value of the "magical_defense" field in the mutation.
func (m *ChangokushiWeaponMutation) MagicalDefense() (r int, exists bool) {
	v := m.magical_defense
	if v == nil {
		return
	}
	return *v, true
}

// OldMagicalDefense returns the old "magical_defense" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldMagicalDefense(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagicalDefense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagicalDefense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagicalDefense: %w", err)
	}
	return oldValue.MagicalDefense, nil
}

// AddMagicalDefense adds i to the "magical_defense" field.
func (m *ChangokushiWeaponMutation) AddMagicalDefense(i int) {
	if m.addmagical_defense != nil {
		*m.addmagical_defense += i
	} else {
		m.addmagical_defense = &i
	}
}

// AddedMagicalDefense returns the value that was added to the "magical_defense" field in this mutation.
func (m *ChangokushiWeaponMutation) AddedMagicalDefense() (r int, exists bool) {
	v := m.addmagical_defense
	if v == nil {
		return
	}
	return *v, true
}

// ResetMagicalDefense resets all changes to the "magical_defense" field.
func (m *ChangokushiWeaponMutation) ResetMagicalDefense() {
	m.magical_defense = nil
	m.addmagical_defense = nil
}

// SetAgility sets the "agility" field.
func (m *ChangokushiWeaponMutation) SetAgility(i int) {
	m.agility = &i
	m.addagility = nil
}

// Agility returns the value of the "agility" field in the mutation.
func (m *ChangokushiWeaponMutation) Agility() (r int, exists bool) {
	v := m.agility
	if v == nil {
		return
	}
	return *v, true
}

// OldAgility returns the old "agility" field's value of the ChangokushiWeapon entity.
// If the ChangokushiWeapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponMutation) OldAgility(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgility: %w", err)
	}
	return oldValue.Agility, nil
}

// AddAgility adds i to the "agility" field.
func (m *ChangokushiWeaponMutation) AddAgility(i int) {
	if m.addagility != nil {
		*m.addagility += i
	} else {
		m.addagility = &i
	}
}

// AddedAgility returns the value that was added to the "agility" field in this mutation.
func (m *ChangokushiWeaponMutation) AddedAgility() (r int, exists bool) {
	v := m.addagility
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgility resets all changes to the "agility" field.
func (m *ChangokushiWeaponMutation) ResetAgility() {
	m.agility = nil
	m.addagility = nil
}

// AddChangeLogIDs adds the "change_logs" edge to the ChangokushiWeaponChangeLog entity by ids.
func (m *ChangokushiWeaponMutation) AddChangeLogIDs(ids ...uint32) {
	if m.change_logs == nil {
		m.change_logs = make(map[uint32]struct{})
	}
	for i := range ids {
		m.change_logs[ids[i]] = struct{}{}
	}
}

// ClearChangeLogs clears the "change_logs" edge to the ChangokushiWeaponChangeLog entity.
func (m *ChangokushiWeaponMutation) ClearChangeLogs() {
	m.clearedchange_logs = true
}

// ChangeLogsCleared reports if the "change_logs" edge to the ChangokushiWeaponChangeLog entity was cleared.
func (m *ChangokushiWeaponMutation) ChangeLogsCleared() bool {
	return m.clearedchange_logs
}

// RemoveChangeLogIDs removes the "change_logs" edge to the ChangokushiWeaponChangeLog entity by IDs.
func (m *ChangokushiWeaponMutation) RemoveChangeLogIDs(ids ...uint32) {
	if m.removedchange_logs == nil {
		m.removedchange_logs = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.change_logs, ids[i])
		m.removedchange_logs[ids[i]] = struct{}{}
	}
}

// RemovedChangeLogs returns the removed IDs of the "change_logs" edge to the ChangokushiWeaponChangeLog entity.
func (m *ChangokushiWeaponMutation) RemovedChangeLogsIDs() (ids []uint32) {
	for id := range m.removedchange_logs {
		ids = append(ids, id)
	}
	return
}

// ChangeLogsIDs returns the "change_logs" edge IDs in the mutation.
func (m *ChangokushiWeaponMutation) ChangeLogsIDs() (ids []uint32) {
	for id := range m.change_logs {
		ids = append(ids, id)
	}
	return
}

// ResetChangeLogs resets all changes to the "change_logs" edge.
func (m *ChangokushiWeaponMutation) ResetChangeLogs() {
	m.change_logs = nil
	m.clearedchange_logs = false
	m.removedchange_logs = nil
}

// Where appends a list predicates to the ChangokushiWeaponMutation builder.
func (m *ChangokushiWeaponMutation) Where(ps ...predicate.ChangokushiWeapon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangokushiWeaponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangokushiWeaponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChangokushiWeapon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangokushiWeaponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangokushiWeaponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChangokushiWeapon).
func (m *ChangokushiWeaponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangokushiWeaponMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, changokushiweapon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, changokushiweapon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, changokushiweapon.FieldDeletedAt)
	}
	if m.uri != nil {
		fields = append(fields, changokushiweapon.FieldURI)
	}
	if m.name != nil {
		fields = append(fields, changokushiweapon.FieldName)
	}
	if m.rank != nil {
		fields = append(fields, changokushiweapon.FieldRank)
	}
	if m._type != nil {
		fields = append(fields, changokushiweapon.FieldType)
	}
	if m.skill != nil {
		fields = append(fields, changokushiweapon.FieldSkill)
	}
	if m.vitality != nil {
		fields = append(fields, changokushiweapon.FieldVitality)
	}
	if m.strength != nil {
		fields = append(fields, changokushiweapon.FieldStrength)
	}
	if m.physical_defense != nil {
		fields = append(fields, changokushiweapon.FieldPhysicalDefense)
	}
	if m.magical_defense != nil {
		fields = append(fields, changokushiweapon.FieldMagicalDefense)
	}
	if m.agility != nil {
		fields = append(fields, changokushiweapon.FieldAgility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangokushiWeaponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case changokushiweapon.FieldCreatedAt:
		return m.CreatedAt()
	case changokushiweapon.FieldUpdatedAt:
		return m.UpdatedAt()
	case changokushiweapon.FieldDeletedAt:
		return m.DeletedAt()
	case changokushiweapon.FieldURI:
		return m.URI()
	case changokushiweapon.FieldName:
		return m.Name()
	case changokushiweapon.FieldRank:
		return m.Rank()
	case changokushiweapon.FieldType:
		return m.GetType()
	case changokushiweapon.FieldSkill:
		return m.Skill()
	case changokushiweapon.FieldVitality:
		return m.Vitality()
	case changokushiweapon.FieldStrength:
		return m.Strength()
	case changokushiweapon.FieldPhysicalDefense:
		return m.PhysicalDefense()
	case changokushiweapon.FieldMagicalDefense:
		return m.MagicalDefense()
	case changokushiweapon.FieldAgility:
		return m.Agility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangokushiWeaponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case changokushiweapon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case changokushiweapon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case changokushiweapon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case changokushiweapon.FieldURI:
		return m.OldURI(ctx)
	case changokushiweapon.FieldName:
		return m.OldName(ctx)
	case changokushiweapon.FieldRank:
		return m.OldRank(ctx)
	case changokushiweapon.FieldType:
		return m.OldType(ctx)
	case changokushiweapon.FieldSkill:
		return m.OldSkill(ctx)
	case changokushiweapon.FieldVitality:
		return m.OldVitality(ctx)
	case changokushiweapon.FieldStrength:
		return m.OldStrength(ctx)
	case changokushiweapon.FieldPhysicalDefense:
		return m.OldPhysicalDefense(ctx)
	case changokushiweapon.FieldMagicalDefense:
		return m.OldMagicalDefense(ctx)
	case changokushiweapon.FieldAgility:
		return m.OldAgility(ctx)
	}
	return nil, fmt.Errorf("unknown ChangokushiWeapon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangokushiWeaponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case changokushiweapon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case changokushiweapon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case changokushiweapon.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case changokushiweapon.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case changokushiweapon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case changokushiweapon.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case changokushiweapon.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case changokushiweapon.FieldSkill:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkill(v)
		return nil
	case changokushiweapon.FieldVitality:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVitality(v)
		return nil
	case changokushiweapon.FieldStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrength(v)
		return nil
	case changokushiweapon.FieldPhysicalDefense:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalDefense(v)
		return nil
	case changokushiweapon.FieldMagicalDefense:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagicalDefense(v)
		return nil
	case changokushiweapon.FieldAgility:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgility(v)
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeapon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangokushiWeaponMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, changokushiweapon.FieldRank)
	}
	if m.addvitality != nil {
		fields = append(fields, changokushiweapon.FieldVitality)
	}
	if m.addstrength != nil {
		fields = append(fields, changokushiweapon.FieldStrength)
	}
	if m.addphysical_defense != nil {
		fields = append(fields, changokushiweapon.FieldPhysicalDefense)
	}
	if m.addmagical_defense != nil {
		fields = append(fields, changokushiweapon.FieldMagicalDefense)
	}
	if m.addagility != nil {
		fields = append(fields, changokushiweapon.FieldAgility)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangokushiWeaponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case changokushiweapon.FieldRank:
		return m.AddedRank()
	case changokushiweapon.FieldVitality:
		return m.AddedVitality()
	case changokushiweapon.FieldStrength:
		return m.AddedStrength()
	case changokushiweapon.FieldPhysicalDefense:
		return m.AddedPhysicalDefense()
	case changokushiweapon.FieldMagicalDefense:
		return m.AddedMagicalDefense()
	case changokushiweapon.FieldAgility:
		return m.AddedAgility()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangokushiWeaponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case changokushiweapon.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case changokushiweapon.FieldVitality:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVitality(v)
		return nil
	case changokushiweapon.FieldStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrength(v)
		return nil
	case changokushiweapon.FieldPhysicalDefense:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhysicalDefense(v)
		return nil
	case changokushiweapon.FieldMagicalDefense:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMagicalDefense(v)
		return nil
	case changokushiweapon.FieldAgility:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgility(v)
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeapon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangokushiWeaponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(changokushiweapon.FieldDeletedAt) {
		fields = append(fields, changokushiweapon.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangokushiWeaponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangokushiWeaponMutation) ClearField(name string) error {
	switch name {
	case changokushiweapon.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeapon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangokushiWeaponMutation) ResetField(name string) error {
	switch name {
	case changokushiweapon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case changokushiweapon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case changokushiweapon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case changokushiweapon.FieldURI:
		m.ResetURI()
		return nil
	case changokushiweapon.FieldName:
		m.ResetName()
		return nil
	case changokushiweapon.FieldRank:
		m.ResetRank()
		return nil
	case changokushiweapon.FieldType:
		m.ResetType()
		return nil
	case changokushiweapon.FieldSkill:
		m.ResetSkill()
		return nil
	case changokushiweapon.FieldVitality:
		m.ResetVitality()
		return nil
	case changokushiweapon.FieldStrength:
		m.ResetStrength()
		return nil
	case changokushiweapon.FieldPhysicalDefense:
		m.ResetPhysicalDefense()
		return nil
	case changokushiweapon.FieldMagicalDefense:
		m.ResetMagicalDefense()
		return nil
	case changokushiweapon.FieldAgility:
		m.ResetAgility()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeapon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangokushiWeaponMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.change_logs != nil {
		edges = append(edges, changokushiweapon.EdgeChangeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangokushiWeaponMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case changokushiweapon.EdgeChangeLogs:
		ids := make([]ent.Value, 0, len(m.change_logs))
		for id := range m.change_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangokushiWeaponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchange_logs != nil {
		edges = append(edges, changokushiweapon.EdgeChangeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangokushiWeaponMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case changokushiweapon.EdgeChangeLogs:
		ids := make([]ent.Value, 0, len(m.removedchange_logs))
		for id := range m.removedchange_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangokushiWeaponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchange_logs {
		edges = append(edges, changokushiweapon.EdgeChangeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangokushiWeaponMutation) EdgeCleared(name string) bool {
	switch name {
	case changokushiweapon.EdgeChangeLogs:
		return m.clearedchange_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangokushiWeaponMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ChangokushiWeapon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangokushiWeaponMutation) ResetEdge(name string) error {
	switch name {
	case changokushiweapon.EdgeChangeLogs:
		m.ResetChangeLogs()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeapon edge %s", name)
}

// ChangokushiWeaponChangeLogMutation represents an operation that mutates the ChangokushiWeaponChangeLog nodes in the graph.
type ChangokushiWeaponChangeLogMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	status                    *string
	price                     *int
	addprice                  *int
	published_at              *time.Time
	clearedFields             map[string]struct{}
	changokushi_weapon        *uint32
	clearedchangokushi_weapon bool
	done                      bool
	oldValue                  func(context.Context) (*ChangokushiWeaponChangeLog, error)
	predicates                []predicate.ChangokushiWeaponChangeLog
}

var _ ent.Mutation = (*ChangokushiWeaponChangeLogMutation)(nil)

// changokushiweaponchangelogOption allows management of the mutation configuration using functional options.
type changokushiweaponchangelogOption func(*ChangokushiWeaponChangeLogMutation)

// newChangokushiWeaponChangeLogMutation creates new mutation for the ChangokushiWeaponChangeLog entity.
func newChangokushiWeaponChangeLogMutation(c config, op Op, opts ...changokushiweaponchangelogOption) *ChangokushiWeaponChangeLogMutation {
	m := &ChangokushiWeaponChangeLogMutation{
		config:        c,
		op:            op,
		typ:           TypeChangokushiWeaponChangeLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangokushiWeaponChangeLogID sets the ID field of the mutation.
func withChangokushiWeaponChangeLogID(id uint32) changokushiweaponchangelogOption {
	return func(m *ChangokushiWeaponChangeLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ChangokushiWeaponChangeLog
		)
		m.oldValue = func(ctx context.Context) (*ChangokushiWeaponChangeLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChangokushiWeaponChangeLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChangokushiWeaponChangeLog sets the old ChangokushiWeaponChangeLog of the mutation.
func withChangokushiWeaponChangeLog(node *ChangokushiWeaponChangeLog) changokushiweaponchangelogOption {
	return func(m *ChangokushiWeaponChangeLogMutation) {
		m.oldValue = func(context.Context) (*ChangokushiWeaponChangeLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangokushiWeaponChangeLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangokushiWeaponChangeLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChangokushiWeaponChangeLog entities.
func (m *ChangokushiWeaponChangeLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangokushiWeaponChangeLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangokushiWeaponChangeLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChangokushiWeaponChangeLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangokushiWeaponChangeLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChangokushiWeaponChangeLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChangokushiWeaponChangeLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChangokushiWeaponChangeLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[changokushiweaponchangelog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[changokushiweaponchangelog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, changokushiweaponchangelog.FieldDeletedAt)
}

// SetChangokushiWeaponID sets the "changokushi_weapon_id" field.
func (m *ChangokushiWeaponChangeLogMutation) SetChangokushiWeaponID(u uint32) {
	m.changokushi_weapon = &u
}

// ChangokushiWeaponID returns the value of the "changokushi_weapon_id" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) ChangokushiWeaponID() (r uint32, exists bool) {
	v := m.changokushi_weapon
	if v == nil {
		return
	}
	return *v, true
}

// OldChangokushiWeaponID returns the old "changokushi_weapon_id" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldChangokushiWeaponID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangokushiWeaponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangokushiWeaponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangokushiWeaponID: %w", err)
	}
	return oldValue.ChangokushiWeaponID, nil
}

// ResetChangokushiWeaponID resets all changes to the "changokushi_weapon_id" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetChangokushiWeaponID() {
	m.changokushi_weapon = nil
}

// SetStatus sets the "status" field.
func (m *ChangokushiWeaponChangeLogMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetStatus() {
	m.status = nil
}

// SetPrice sets the "price" field.
func (m *ChangokushiWeaponChangeLogMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ChangokushiWeaponChangeLogMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *ChangokushiWeaponChangeLogMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *ChangokushiWeaponChangeLogMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the ChangokushiWeaponChangeLog entity.
// If the ChangokushiWeaponChangeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangokushiWeaponChangeLogMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *ChangokushiWeaponChangeLogMutation) ResetPublishedAt() {
	m.published_at = nil
}

// ClearChangokushiWeapon clears the "changokushi_weapon" edge to the ChangokushiWeapon entity.
func (m *ChangokushiWeaponChangeLogMutation) ClearChangokushiWeapon() {
	m.clearedchangokushi_weapon = true
	m.clearedFields[changokushiweaponchangelog.FieldChangokushiWeaponID] = struct{}{}
}

// ChangokushiWeaponCleared reports if the "changokushi_weapon" edge to the ChangokushiWeapon entity was cleared.
func (m *ChangokushiWeaponChangeLogMutation) ChangokushiWeaponCleared() bool {
	return m.clearedchangokushi_weapon
}

// ChangokushiWeaponIDs returns the "changokushi_weapon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangokushiWeaponID instead. It exists only for internal usage by the builders.
func (m *ChangokushiWeaponChangeLogMutation) ChangokushiWeaponIDs() (ids []uint32) {
	if id := m.changokushi_weapon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangokushiWeapon resets all changes to the "changokushi_weapon" edge.
func (m *ChangokushiWeaponChangeLogMutation) ResetChangokushiWeapon() {
	m.changokushi_weapon = nil
	m.clearedchangokushi_weapon = false
}

// Where appends a list predicates to the ChangokushiWeaponChangeLogMutation builder.
func (m *ChangokushiWeaponChangeLogMutation) Where(ps ...predicate.ChangokushiWeaponChangeLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangokushiWeaponChangeLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangokushiWeaponChangeLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChangokushiWeaponChangeLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangokushiWeaponChangeLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangokushiWeaponChangeLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChangokushiWeaponChangeLog).
func (m *ChangokushiWeaponChangeLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangokushiWeaponChangeLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, changokushiweaponchangelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, changokushiweaponchangelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, changokushiweaponchangelog.FieldDeletedAt)
	}
	if m.changokushi_weapon != nil {
		fields = append(fields, changokushiweaponchangelog.FieldChangokushiWeaponID)
	}
	if m.status != nil {
		fields = append(fields, changokushiweaponchangelog.FieldStatus)
	}
	if m.price != nil {
		fields = append(fields, changokushiweaponchangelog.FieldPrice)
	}
	if m.published_at != nil {
		fields = append(fields, changokushiweaponchangelog.FieldPublishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangokushiWeaponChangeLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case changokushiweaponchangelog.FieldCreatedAt:
		return m.CreatedAt()
	case changokushiweaponchangelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case changokushiweaponchangelog.FieldDeletedAt:
		return m.DeletedAt()
	case changokushiweaponchangelog.FieldChangokushiWeaponID:
		return m.ChangokushiWeaponID()
	case changokushiweaponchangelog.FieldStatus:
		return m.Status()
	case changokushiweaponchangelog.FieldPrice:
		return m.Price()
	case changokushiweaponchangelog.FieldPublishedAt:
		return m.PublishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangokushiWeaponChangeLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case changokushiweaponchangelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case changokushiweaponchangelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case changokushiweaponchangelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case changokushiweaponchangelog.FieldChangokushiWeaponID:
		return m.OldChangokushiWeaponID(ctx)
	case changokushiweaponchangelog.FieldStatus:
		return m.OldStatus(ctx)
	case changokushiweaponchangelog.FieldPrice:
		return m.OldPrice(ctx)
	case changokushiweaponchangelog.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChangokushiWeaponChangeLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangokushiWeaponChangeLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case changokushiweaponchangelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case changokushiweaponchangelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case changokushiweaponchangelog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case changokushiweaponchangelog.FieldChangokushiWeaponID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangokushiWeaponID(v)
		return nil
	case changokushiweaponchangelog.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case changokushiweaponchangelog.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case changokushiweaponchangelog.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeaponChangeLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangokushiWeaponChangeLogMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, changokushiweaponchangelog.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangokushiWeaponChangeLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case changokushiweaponchangelog.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangokushiWeaponChangeLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case changokushiweaponchangelog.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeaponChangeLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangokushiWeaponChangeLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(changokushiweaponchangelog.FieldDeletedAt) {
		fields = append(fields, changokushiweaponchangelog.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangokushiWeaponChangeLogMutation) ClearField(name string) error {
	switch name {
	case changokushiweaponchangelog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeaponChangeLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangokushiWeaponChangeLogMutation) ResetField(name string) error {
	switch name {
	case changokushiweaponchangelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case changokushiweaponchangelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case changokushiweaponchangelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case changokushiweaponchangelog.FieldChangokushiWeaponID:
		m.ResetChangokushiWeaponID()
		return nil
	case changokushiweaponchangelog.FieldStatus:
		m.ResetStatus()
		return nil
	case changokushiweaponchangelog.FieldPrice:
		m.ResetPrice()
		return nil
	case changokushiweaponchangelog.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeaponChangeLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.changokushi_weapon != nil {
		edges = append(edges, changokushiweaponchangelog.EdgeChangokushiWeapon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case changokushiweaponchangelog.EdgeChangokushiWeapon:
		if id := m.changokushi_weapon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchangokushi_weapon {
		edges = append(edges, changokushiweaponchangelog.EdgeChangokushiWeapon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangokushiWeaponChangeLogMutation) EdgeCleared(name string) bool {
	switch name {
	case changokushiweaponchangelog.EdgeChangokushiWeapon:
		return m.clearedchangokushi_weapon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangokushiWeaponChangeLogMutation) ClearEdge(name string) error {
	switch name {
	case changokushiweaponchangelog.EdgeChangokushiWeapon:
		m.ClearChangokushiWeapon()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeaponChangeLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangokushiWeaponChangeLogMutation) ResetEdge(name string) error {
	switch name {
	case changokushiweaponchangelog.EdgeChangokushiWeapon:
		m.ResetChangokushiWeapon()
		return nil
	}
	return fmt.Errorf("unknown ChangokushiWeaponChangeLog edge %s", name)
}

// SanmeiHoikuenPostMutation represents an operation that mutates the SanmeiHoikuenPost nodes in the graph.
type SanmeiHoikuenPostMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	url           *string
	title         *string
	date          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SanmeiHoikuenPost, error)
	predicates    []predicate.SanmeiHoikuenPost
}

var _ ent.Mutation = (*SanmeiHoikuenPostMutation)(nil)

// sanmeihoikuenpostOption allows management of the mutation configuration using functional options.
type sanmeihoikuenpostOption func(*SanmeiHoikuenPostMutation)

// newSanmeiHoikuenPostMutation creates new mutation for the SanmeiHoikuenPost entity.
func newSanmeiHoikuenPostMutation(c config, op Op, opts ...sanmeihoikuenpostOption) *SanmeiHoikuenPostMutation {
	m := &SanmeiHoikuenPostMutation{
		config:        c,
		op:            op,
		typ:           TypeSanmeiHoikuenPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSanmeiHoikuenPostID sets the ID field of the mutation.
func withSanmeiHoikuenPostID(id uint32) sanmeihoikuenpostOption {
	return func(m *SanmeiHoikuenPostMutation) {
		var (
			err   error
			once  sync.Once
			value *SanmeiHoikuenPost
		)
		m.oldValue = func(ctx context.Context) (*SanmeiHoikuenPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SanmeiHoikuenPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSanmeiHoikuenPost sets the old SanmeiHoikuenPost of the mutation.
func withSanmeiHoikuenPost(node *SanmeiHoikuenPost) sanmeihoikuenpostOption {
	return func(m *SanmeiHoikuenPostMutation) {
		m.oldValue = func(context.Context) (*SanmeiHoikuenPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SanmeiHoikuenPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SanmeiHoikuenPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SanmeiHoikuenPost entities.
func (m *SanmeiHoikuenPostMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SanmeiHoikuenPostMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SanmeiHoikuenPostMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SanmeiHoikuenPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SanmeiHoikuenPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SanmeiHoikuenPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SanmeiHoikuenPost entity.
// If the SanmeiHoikuenPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SanmeiHoikuenPostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SanmeiHoikuenPostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SanmeiHoikuenPostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SanmeiHoikuenPostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SanmeiHoikuenPost entity.
// If the SanmeiHoikuenPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SanmeiHoikuenPostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SanmeiHoikuenPostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SanmeiHoikuenPostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SanmeiHoikuenPostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SanmeiHoikuenPost entity.
// If the SanmeiHoikuenPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SanmeiHoikuenPostMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SanmeiHoikuenPostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sanmeihoikuenpost.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SanmeiHoikuenPostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sanmeihoikuenpost.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SanmeiHoikuenPostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sanmeihoikuenpost.FieldDeletedAt)
}

// SetURL sets the "url" field.
func (m *SanmeiHoikuenPostMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SanmeiHoikuenPostMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SanmeiHoikuenPost entity.
// If the SanmeiHoikuenPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SanmeiHoikuenPostMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *SanmeiHoikuenPostMutation) ResetURL() {
	m.url = nil
}

// SetTitle sets the "title" field.
func (m *SanmeiHoikuenPostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SanmeiHoikuenPostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SanmeiHoikuenPost entity.
// If the SanmeiHoikuenPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SanmeiHoikuenPostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SanmeiHoikuenPostMutation) ResetTitle() {
	m.title = nil
}

// SetDate sets the "date" field.
func (m *SanmeiHoikuenPostMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *SanmeiHoikuenPostMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the SanmeiHoikuenPost entity.
// If the SanmeiHoikuenPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SanmeiHoikuenPostMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *SanmeiHoikuenPostMutation) ResetDate() {
	m.date = nil
}

// Where appends a list predicates to the SanmeiHoikuenPostMutation builder.
func (m *SanmeiHoikuenPostMutation) Where(ps ...predicate.SanmeiHoikuenPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SanmeiHoikuenPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SanmeiHoikuenPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SanmeiHoikuenPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SanmeiHoikuenPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SanmeiHoikuenPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SanmeiHoikuenPost).
func (m *SanmeiHoikuenPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SanmeiHoikuenPostMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, sanmeihoikuenpost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sanmeihoikuenpost.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sanmeihoikuenpost.FieldDeletedAt)
	}
	if m.url != nil {
		fields = append(fields, sanmeihoikuenpost.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, sanmeihoikuenpost.FieldTitle)
	}
	if m.date != nil {
		fields = append(fields, sanmeihoikuenpost.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SanmeiHoikuenPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sanmeihoikuenpost.FieldCreatedAt:
		return m.CreatedAt()
	case sanmeihoikuenpost.FieldUpdatedAt:
		return m.UpdatedAt()
	case sanmeihoikuenpost.FieldDeletedAt:
		return m.DeletedAt()
	case sanmeihoikuenpost.FieldURL:
		return m.URL()
	case sanmeihoikuenpost.FieldTitle:
		return m.Title()
	case sanmeihoikuenpost.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SanmeiHoikuenPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sanmeihoikuenpost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sanmeihoikuenpost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sanmeihoikuenpost.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sanmeihoikuenpost.FieldURL:
		return m.OldURL(ctx)
	case sanmeihoikuenpost.FieldTitle:
		return m.OldTitle(ctx)
	case sanmeihoikuenpost.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown SanmeiHoikuenPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SanmeiHoikuenPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sanmeihoikuenpost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sanmeihoikuenpost.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sanmeihoikuenpost.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sanmeihoikuenpost.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case sanmeihoikuenpost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sanmeihoikuenpost.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown SanmeiHoikuenPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SanmeiHoikuenPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SanmeiHoikuenPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SanmeiHoikuenPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SanmeiHoikuenPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SanmeiHoikuenPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sanmeihoikuenpost.FieldDeletedAt) {
		fields = append(fields, sanmeihoikuenpost.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SanmeiHoikuenPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SanmeiHoikuenPostMutation) ClearField(name string) error {
	switch name {
	case sanmeihoikuenpost.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SanmeiHoikuenPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SanmeiHoikuenPostMutation) ResetField(name string) error {
	switch name {
	case sanmeihoikuenpost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sanmeihoikuenpost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sanmeihoikuenpost.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sanmeihoikuenpost.FieldURL:
		m.ResetURL()
		return nil
	case sanmeihoikuenpost.FieldTitle:
		m.ResetTitle()
		return nil
	case sanmeihoikuenpost.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown SanmeiHoikuenPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SanmeiHoikuenPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SanmeiHoikuenPostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SanmeiHoikuenPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SanmeiHoikuenPostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SanmeiHoikuenPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SanmeiHoikuenPostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SanmeiHoikuenPostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SanmeiHoikuenPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SanmeiHoikuenPostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SanmeiHoikuenPost edge %s", name)
}
